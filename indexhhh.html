<html>
	<head>
		<title>My first three.js app</title>
		<style>
		body{
overflow: hidden;
margin: 0;
}

		</style>
	</head>
	<body>


<div id ="pl0" style="position:absolute;display:block;background: #00ff00;width:20%;height: 20%; top:77%;left:2%"></div>

<div id ="pl1" style="position:absolute;display:block;background: #f0f000;width:20%;height: 20%; top:77%;left:18%"></div>
<div id ="pl2" style="position:absolute;display:block;background: #0000ff;width:20%;height: 20%; top:77%;left:34%"></div>
<div id ="pl3" style="position:absolute;display:block;background: #000f00;width:20%;height: 20%; top:77%;left:50%"></div>
<div id ="pl4" style="position:absolute;display:block;background: #0000ff;width:20%;height: 20%; top:77%;left:66%"></div>
<div id ="pl5" style="position:absolute;display:block;background: #0ff0ff;width:20%;height: 20%; top:77%;left:82%"></div>
		<script src="/three.min.js"></script>
		<script src="/OrbitControls.js"></script>
			<script src="/GLTFLoader.js"></script>


		<script>
		var clock = new THREE.Clock();
		var isMouseDown=false;
		var ev;
		document.body.onselectstart = function() {return false;};
var movmen=1;
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
		camera.position.set(37.25750026921661,34.86101181265435,12.261872901410912);
		var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.autoClear = false;
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setClearColor(0x101005);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		document.body.appendChild(renderer.domElement);
var controls = new THREE.OrbitControls(camera, renderer.domElement);








lightFly2= new THREE.PointLight();
      lightFly2.position.set(3,.5,1);
      lightFly2.intensity=1;
      lightFly2.distance=100;
      scene.add(lightFly2);

			light2 = new THREE.SpotLight();
							light2.position.set(1000,1000,0);
			        light2.castShadow = true;
							light2.intensity=3;
			        scene.add(light2);
var tloader = new THREE.TextureLoader();
var tled = tloader.load( "/ХОХХЕЙ.jpg" );
tled.generateMipmaps = false;
tled.magFilter = THREE.LinearFilter;
tled.minFilter = THREE.LinearFilter;



var ms=[];
var h=[],s,k,led;
var box = new THREE.Box3();
loader = new THREE.GLTFLoader();
            loader.load( '/хокер.glb', function ( load ) {
							var tloader = new THREE.TextureLoader();
							var tsh = tloader.load( "/sh.jpg" );
							tsh.generateMipmaps = false;
							tsh.magFilter = THREE.LinearFilter;
							tsh.minFilter = THREE.LinearFilter;
							tsh.flipY=false;
h[0]=load.scene.getObjectByName(`хокер`);

									h[0].position.x=-20;h[0].position.z=-13.66;//ld
h[1]=h[0].clone(); h[1].position.x=-10;h[1].position.z=28.3;//lb
h[2]=h[0].clone(); h[2].position.x=-0;h[2].position.z=28.3;//вратарь
h[3]=h[0].clone(); h[3].position.x=0;h[3].position.z=-13.66;//center
h[4]=h[0].clone(); h[4].position.x=10;h[4].position.z=28.3;//pb
h[5]=h[0].clone(); h[5].position.x=20;h[5].position.z=-13.66;//pd

for (var i = 0; i < h.length; i++) {h[i].material.side=2;
	h[i].material.map=tsh;
	h[i].movx=0;
	h[i].movy=0;
	interseki.push(h[i]);
	//intersekorob.push(h[i]);
	scene.add(h[i]);scene.updateMatrixWorld();
};
document.getElementById('pl0').addEventListener( "mousemove", click1);
document.getElementById('pl1').addEventListener( "mousemove", click2);
document.getElementById('pl2').addEventListener( "mousemove", click3);
document.getElementById('pl3').addEventListener( "mousemove", click4);
document.getElementById('pl4').addEventListener( "mousemove", click5);
document.getElementById('pl5').addEventListener( "mousemove", click6);
//document.getElementById('pl4').addEventListener( "mousemove", clickd);


//h.geometry.computeBoundingBox();

loader.load( '/шайба.glb', function ( load ) {
s=load.scene.getObjectByName(`шайба`);
scene.add(s);
s.geometry.computeBoundingSphere();

loader.load( '/коробка.glb', function ( load ) {
k=load.scene.getObjectByName(`КОРОБКА`);
k.material.side=2;
scene.add(k);




//ms['dia'].scene.getObjectByName("Circle").material.side=2;
//ms['dia'].scene.getObjectByName("Circle").material.map=texture['rose'];
intersekorob.push(k);scene.updateMatrixWorld();
loader.load( '/лед.glb', function ( load ) {
led=load.scene.getObjectByName(`лед`);
led.material.side=2;

led.material.map=tled;
scene.add(led);



render();
//h.material=new THREE.MeshBasicMaterial;

});
});
});
});


var time=0;

var angle;var mov;
var interseki=[];var intersekorob=[];
var raycaster = new THREE.Raycaster();
raycaster.far=1;
var xz=new THREE.Vector3();
var raycaster2 = new THREE.Raycaster();
raycaster2.far=2;
var xz2=new THREE.Vector3();
var t3,t4;
var dir = new THREE.Vector3( 1, 2, 0 );

//normalize the direction vector (convert to vector of length 1)
dir.normalize();

var origin = new THREE.Vector3( 0, 0, 0 );
var length = raycaster.far;
var hex = 0xffff00;

var arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
scene.add( arrowHelper );

var katitsa=false;




function inter() {
	for (var i = 0; i < Math.PI*8; i+=Math.PI/24) {
		xz.setFromCylindricalCoords ( 1, i, 0 );
	arrowHelper.setDirection (xz);
	raycaster.set(s.position,xz);
	intersects = raycaster.intersectObjects( interseki );

	if (intersects.length){udar2()}};
};

function interkor() {raycaster2.set(s.position,xz2);
	intersects = raycaster2.intersectObjects( intersekorob );

	if (intersects.length){uk();}
};

function udar() {
katitsa=false;
tochka2=new THREE.Vector3().subVectors(intersects[0].point,s.position).normalize();
tochka2.reflect(intersects[0].face.normal).normalize();
tochka2.negate();
tochka2.reflect(intersects[0].face.normal).normalize();
moved=intersects[0].object.movy+intersects[0].object.movx;
s.position.x+=tochka2.x/10+Math.abs(moved)/5000;
s.position.z+=tochka2.z/10+Math.abs(moved)/5000;
katitsa=true;};
const x=new THREE.Vector3( 1, 0, 0);
const y=new THREE.Vector3( 0, 1, 0);
const z=new THREE.Vector3( 0, 0, 1);
var ud=false;
var CRSR=new THREE.Vector3;
CRSR.a=new THREE.Vector3;
CRSR.p=new THREE.Vector3;
CRSR.q=new THREE.Vector3;
CRSR.lp=new THREE.Vector3;
CRSR.rp=new THREE.Vector3;
CRSR.lq=new THREE.Vector3;
CRSR.rq=new THREE.Vector3;
CRSR.o=new THREE.Vector3;
function krest(obj) {
	CRSR.p.copy(obj.position);
	CRSR.q.copy(obj.quaternion);
	CRSR.lp.copy(CRSR.p);
	CRSR.lq.copy(CRSR.q);
	CRSR.rp.copy(CRSR.p);
	CRSR.rq.copy(CRSR.q);
	CRSR.o.copy(z);
	CRSR.o.applyQuaternion(obj.quaternion);
	CRSR.p.add(CRSR.o.multiplyScalar(1));
	CRSR.o.copy(x);
	CRSR.o.applyQuaternion(obj.quaternion);
	CRSR.lp.add(CRSR.o.multiplyScalar(-2));
	CRSR.o.copy(x);
	CRSR.o.applyQuaternion(obj.quaternion);
	CRSR.rp.add(CRSR.o.multiplyScalar(2));
}
var levo,pravo;
function udar2() {//ud=true;
//katitsa=false;
levo=s.position.distanceTo(CRSR.lp)
pravo=s.position.distanceTo(CRSR.rp)
//if(levo>pravo){console.log('levo')}else{console.log('pravo');};

moved=intersects[0].object.movy+intersects[0].object.movx;
if (moved>31)moved=0;
//console.log(moved);
tochka2=new THREE.Vector3().subVectors(intersects[0].point,s.position).normalize();

tochka2.reflect(intersects[0].face.normal).normalize();
tochka2.negate();
tochka2.reflect(intersects[0].face.normal).normalize();



//moved=intersects[0].object.movy+intersects[0].object.movx;
//console.log('udar');
//moved=3;
//s.position.x+=tochka2.x/10+moved/2500;
//s.position.z+=tochka2.z/10+moved/2500;
//s.position.x+=tochka2.x/10+moved/2500;
//s.position.z+=tochka2.z/10+moved/2500;
//console.log(intersects);
if (moved<10){
if (intersects[0].point.distanceTo(s.position)<s.geometry.boundingSphere.radius) {
	s.position.add(tochka2.multiplyScalar(s.geometry.boundingSphere.radius/8));
}}
if (moved>10){
if (intersects[0].point.distanceTo(s.position)<s.geometry.boundingSphere.radius) {
	s.position.add(tochka2.multiplyScalar(s.geometry.boundingSphere.radius));
}}

katitsa=true;//ud=false;
//obnuleniemoveda(intersects[0].object);
//ud=false;
//setTimeout(to, 100);
};
function to() {
ud=false;
}



function uk() {
	katitsa=false;
	tochka2=new THREE.Vector3().subVectors(intersects[0].point,s.position).normalize();
	tochka2.reflect(intersects[0].face.normal).normalize();
	moved=moved/2;
	s.position.x+=tochka2.x/10+Math.abs(moved)/500;
	s.position.z+=tochka2.z/10+Math.abs(moved)/500;
	katitsa=true;
	};







		function render(){
		  requestAnimationFrame(render);
			//xz.negate();
			time++;arrowHelper.position.copy(s.position);
			//if (!ScanTest)scanRay();
			//xz.set(Math.sin(time*1000),0.1,Math.cos(time*1000));arrowHelper.setDirection (xz);
			//inter();
			//xz.set(Math.sin(time*100000),0,Math.cos(time*100000));
			//inter();
			//luch();
			//box.copy( h.geometry.boundingBox ).applyMatrix4( h.matrixWorld );
			//if (box.intersectsSphere (s.geometry.boundingSphere))console.log('o');

			//xz.set(0,0,0);


inter();
/*
xz.set(-Math.sin(time*100000),0,Math.cos(time*100000));
inter();
xz.set(-Math.sin(time*100000),0,Math.cos(time*100000));
inter();

*/

//origin.copy(s.position);

if (katitsa){//if(ud==false)inter();
	//if (moved>15)moved=15;
	//if (moved<-15)moved=-15;
	if (moved>0)moved-=0.04;
	if (moved<0)moved=0.0;

	//if (moved<0)moved=0;
	//s.position.x-=tochka2.x/10*Math.abs(mov);
	//s.position.y+=tochka.y*movmen;
	//s.position.z-=tochka2.z/10*Math.abs(mov);

	s.position.x+=tochka2.x/15*(moved/1.1);
	//s.position.y+=tochka.y*movmen;
	s.position.z+=tochka2.z/15*(moved/1.1);

	xz2.set(tochka2.x,tochka2.y,tochka2.z);interkor();
	//xz.set(tochka2.x,tochka2.y,tochka2.z);inter();
//if (!ScanTest)scanRay();

}



		  renderer.render(scene, camera);
		}

		var mov;var moved;

var pruz=21;
		function muv(obj, movx, movy) {
			obj.movy=movy;obj.movx=movx;
if (obj.movy>pruz)obj.movy=pruz;
if (obj.movx>pruz)obj.movx=pruz;
if (obj.movy<-pruz)obj.movy=-pruz;
if (obj.movx<-pruz)obj.movx=-pruz;

			obj.rotation.y+=obj.movx*(Math.PI/134);

obj.position.z+=obj.movy/8;

			obj.movy=Math.abs(obj.movy);
			obj.movx=Math.abs(obj.movx);//console.log(obj.movx)
			//moved=obj.movy+obj.movx;
			krest(obj);
			inter();
obj.movy=0;obj.movx=0;
		};
		function obnuleniemoveda(obj) {
			obj.movy=0;obj.movx=0;
		};


function click1(e) {if(e.buttons==1)muv(h[0],e.movementX,e.movementY)};
function click2(e) {if(e.buttons==1)muv(h[1],e.movementX,e.movementY)};
function click3(e) {if(e.buttons==1)muv(h[2],e.movementX,e.movementY)};
function click4(e) {if(e.buttons==1){muv(h[3],e.movementX,e.movementY);;}};
function click5(e) {if(e.buttons==1)muv(h[4],e.movementX,e.movementY)};
function click6(e) {if(e.buttons==1)muv(h[5],e.movementX,e.movementY)};
		</script>

	</body>
</html>
